#!/usr/bin/python -O

"""burgaur - A delicious AUR helper. Made from cower.

Burgaur is strictly a superset of cower. It automates of boring tasks
that in cower you need to do by hand, like updating all your AUR system
packages or installing a new package from AUR including its
dependencies.

It doesn't try to be everything (i.e. like yaourt). Instead, it simple
assume that there is already a better tool to do some job and only
tries to complement other tools.

"""

import argparse
import os
import re
import subprocess
import sys
import tempfile
from distutils.spawn import find_executable
from shutil import rmtree
from textwrap import dedent

__author__ = "Thiago Kenji Okada"
__license__ = "MIT"
__version__ = "0.6"
__maintainer__ = "Thiago Kenji Okada"
__email__ = "thiago DOT mast3r AT gmail DOT com"
__status__ = "Development"

COWER_URL = "https://aur.archlinux.org/packages/cower/"
PACMAN_PATH = find_executable("pacman")
MAKEPKG_PATH = find_executable("makepkg")
COWER_PATH = find_executable("cower")
COWER_CMD = [COWER_PATH]
MC_PATH = find_executable("mc")  # mc is an optional dependency
ENCODING = os.getenv("LANG", ".utf8").split(".")[1]
# In Arch Linux, /tmp is mounted as tmpfs. It would be a bad idea to compile
# big packages completely on RAM, so by default we use /var/tmp. Anyway, the
# user can overrides this setting by setting env variable BURGAUR_TARGET_DIR.
tempfile.tempdir = os.getenv("BURGAUR_TARGET_DIR", "/var/tmp")


# Internal error class
class BurgaurError(Exception):
    pass


# Auxiliary functions
def query_yes_no(question, default=None):
    """Ask a yes/no question via input() and return their answer.

    Return True in case of "yes" and False in case of "no".

    Modified version from http://stackoverflow.com/a/3041990, rewrite
    some parts to be more Pythonic.

    Keyword arguments:
    question -- string present to the user
    default -- default answer if the user just hits enter; None doesn't
    assume anything (default: None).
    """
    valid = {"yes": True, "y": True,
             "no": False, "n": False}
    if default is None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("Invalid default answer: {}".format(default))

    while True:
        print("{}{}".format(question, prompt), end="")
        choice = input().lower()
        try:
            if choice:
                return valid[choice]
            else:
                return valid[default]
        except KeyError:
            print("Please respond with (y)es or (n)o.")


def parse_int_from_input(prompt=None):
    """Ask input from user, tries to parse input for integers.

    User may pass only one value ("0"), multiple values separated by
    comma ("0,1,5") or a range of values separated by dash ("2-8").

    For now, this is a pretty dumb parser: it only supports one format
    OR another (so you can only pass comma separated values or a range
    of them, not both). I may fix this someday, but it works for now.

    Keyword arguments:
    prompt -- prompt from input() function (default: None)
    """
    parse_help = dedent("""
                        Invalid value, some valid inputs:
                        0  # single value, returns 0
                        0,1,4  # multiple values, returns 0,1,4
                        0-3  # range of values, returns 0,1,2,3
                        """)

    while True:
        user_input = input(prompt)
        result = []
        try:
            # If user only entered a number, will be passed here
            result.append(int(user_input))
            break
        except ValueError:
            # User may have entered more than a number separated by comma
            try:
                for number in user_input.split(","):
                    result.append(int(number))
                break
            except ValueError:
                # User may have entered a range separated by dash
                try:
                    i, j = user_input.split("-")
                    number_range = list(range(int(i), int(j) + 1))
                    result = list(number_range)
                    break
                except ValueError:
                    # Does not seem to be a valid input, show user help
                    print(parse_help, file=sys.stderr)
    return result


def view_in_mc(package, directory="."):
    """"View package contents with Midnight Commander.

    Keyword arguments:
    package -- package name
    directory -- directory to open in mc (default: ".")
    """
    if MC_PATH:  # only runs if mc is installed, otherwise ignore it
        query = query_yes_no("Do you want to view package {} contents in mc?"
                             .format(package), default="yes")
        if query:
            subprocess.call([MC_PATH, directory])


# AUR related functions
def check_updates():
    """Check available updates for AUR packages.

    In case of sucess it returns a list of strings with each package
    that can be updated or None if there is no update available.
    In case of error it force exit with return code 1, including a user
    friendly message.

    Raises a BurgaurError in case of error.
    """
    cmd = COWER_CMD + ["--color=never", "--update", "--quiet"]
    process = subprocess.Popen(cmd, stdout=subprocess.PIPE)
    out, err = process.communicate()

    # According to this issue https://github.com/falconindy/cower/issues/32,
    # cower returns 1 if there is packages to update, 0 if there is nothing,
    # and anything else if there is a error.
    if process.returncode == 1:
        packages = out.decode(encoding=ENCODING).split("\n")[:-1]
        return packages
    elif process.returncode == 0:
        return None
    else:
        raise BurgaurError("Error while checking for updates.")


def force_update(target, non_interactive=False):
    """Force update of packages from AUR with target name.

    The user case of this function is to update VCS packages. For
    example, you could pass target="-git", and since the majority of
    Git packages on AUR finishes with "-git" prefix it would try to
    update all of them.

    Since it's impossible to know if VCS packages are up-to-date or not
    unless we build it and try to install, please doesn't expect any
    intelligence from using this function.

    target -- a package name or a generic target; support glob
    expansion
    non_interactive -- update all packages without asking for user
    input; affect make_install function too (default: False)
    """
    cmd = [PACMAN_PATH, "-Q", "--foreign", "--quiet", "--color", "never"]
    installed_packages = subprocess.check_output(cmd)
    installed_packages = installed_packages.decode(encoding=ENCODING)
    installed_packages = installed_packages.split("\n")[:-1]
    filtered_packages = list(filter(lambda x: re.search(target, x),
                                    installed_packages))

    print("Packages to update:", end=" ")
    print(*filtered_packages, sep=", ")

    for package in filtered_packages:
        try:
            make_install(package, non_interactive=non_interactive)
        except BurgaurError as e:
            # Ignore make_install errors in this case
            print(e, file=sys.stderr)


def make_install(package, install_deps=False, non_interactive=False):
    """Download, make and install package.

    This function creates a temporary directory, downloads the PKGBUILD
    using 'cower -d' and make/install the package using 'makepkg -si'
    command.

    Raises a BurgaurError in case of error.

    Keyword arguments:
    package -- desired package to be installed (must match a package
    name on AUR)
    install_deps -- use cower '-dd' instead of only '-d' to download
    AUR dependencies and install them before the main package (default:
    False)
    non_interactive -- skip interactive prompts during install process;
    WARNING: possibly unsafe (default: False)
    """

    def _get_package_base(package):
        """Get package base name.

        This is an ugly hack until this issue is solved:
        https://github.com/falconindy/cower/issues/105

        Keyword arguments:
        package -- package to get PackageBase information
        """
        cower_cmd = COWER_CMD + ["--color=never", "--info", package]
        try:
            out = subprocess.check_output(cower_cmd).decode(ENCODING)
        except subprocess.CalledProcessError:
            raise BurgaurError("Error while getting package {} info."
                               .format(target))
        result = re.findall(r"PackageBase\s+: (.+)", out)
        if result:
            return result[0]
        else:
            return None

    if not non_interactive:
        query = query_yes_no("Do you want to install package {}"
                             .format(package), default="yes")
        if not query:
            return

    target_dir = tempfile.mkdtemp(prefix="burgaur-")
    makepkg_cmd = [MAKEPKG_PATH, "--syncdeps", "--install"]
    cower_cmd = COWER_CMD + ["--color=never", "--quiet",
                             "--download", package,
                             "--target", target_dir]
    if install_deps:
        cower_cmd += ["--download"]

    os.chdir(target_dir)
    try:
        subprocess.check_call(cower_cmd)
    except subprocess.CalledProcessError:
        raise BurgaurError("Error while downloading package {} or its "
                           "depedencies.".format(package))
    try:
        packages = os.listdir()
        # We remove and append the package in packages list to ensure
        # that the dependencies are installed before the main package.
        try:
            packages.remove(package)
            packages.append(package)
        except ValueError:
            # We could remove this try by deciding from _get_package_base
            # output if there is or not a PackageBase, but _get_package_base
            # is slow.
            package_base = _get_package_base(package)
            if package_base:
                print("PackageBase {} found.".format(package_base))
                packages.remove(package_base)
                packages.append(package_base)
            else:
                raise BurgaurError("Directory from package {} not found, and"
                                   " not a splitted package.".format(package))
        for package in packages:
            os.chdir(package)
            if not non_interactive:
                view_in_mc(package)
            subprocess.check_call(makepkg_cmd)
            os.chdir(target_dir)
    except subprocess.CalledProcessError:
        raise BurgaurError("Error while installing package {}."
                           .format(package))
    finally:
        rmtree(target_dir)


def system_update(non_interactive=False):
    """Updates all AUR packages that have updates.

    Keyword arguments:
    non_interactive -- see make_install function (default: False)
    """
    packages = check_updates()
    if packages:
        print("Packages to update:", end=" ")
        print(*packages, sep=", ")

        for package in packages:
            try:
                make_install(package, non_interactive=non_interactive)
            except BurgaurError as e:
                # Ignore make_install errors in this case
                print(e, file=sys.stderr)
    else:
        print("All packages are up-to-date.")


def search_package(target):
    """Search and returns packages that matches target.

    This function uses 'cower -s target' to search packages that
    matches a certain target, parse cower output and returns a list
    of dictionaries containing info about all finded packages.

    Each dictionary contains the following keys: category, name,
    version, description, maintainer and votes. For now this info is
    hard-coded but it may be dynamically generated in the future.

    Keyword arguments:
    target -- target for 'cower -s target'
    """
    package_info = ["category", "name", "version",
                    "description", "maintainer", "votes"]
    # output: package++1.0.0++package description++maintainer++123\n
    cmd = COWER_CMD + ["--format=%c++%n++%v++%d++%m++%o\n",
                       "--color=never",
                       "--search", target]
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = p.communicate()
    if err:
        raise BurgaurError("Error while searching for target {}"
                           .format(target))

    result = []
    packages = out.decode(ENCODING).split("\n")[:-1]
    for package in packages:
        result.append(dict(zip(package_info, package.split("++"))))
    return result


def search_install(target, non_interactive=False):
    """Search target, display packages that match it and install them.

    This function searches the target on AUR, display all results to
    the user in a enumerated way and ask user which ones it should
    install.

    Keyword arguments:
    target -- target to search on AUR
    non_interactive -- see make_install function (default: False)
    """
    packages = search_package(target)
    for i, package in enumerate(packages):
        print("{}) {}/{} by {} {} ({})\n    {}".format(i,
                                                       package["category"],
                                                       package["name"],
                                                       package["maintainer"],
                                                       package["version"],
                                                       package["votes"],
                                                       package["description"]))
    selected_packages = parse_int_from_input("Select packages (use comma to "
                                             "select multiple packages, "
                                             "dash for ranges): ")
    for i in selected_packages:
        make_install(packages[i]["name"], True, non_interactive)


# main() and auxiliary functions
def _argparser():
    """Print and parse arguments"""
    program_name = os.path.basename(sys.argv[0]).title()
    url = "http://www.retrojunkie.com/asciiart/food/burgers.htm"
    python_version = sys.version_info[:3]
    version_info = dedent(
        r'''
                          {0}
                 _....----"""----...._
              .-'  o    o    o    o   '-.
             /  o    o    o         o    \
            /     o      o   o     o    o \
          _|   o   o    o      o  o     o  |_
         / `''-----.................-----''` \
         \___________________________________/
           \~`-`.__.`-~`._.~`-`~.-~.__.~`-`/
            \                             /
             `-._______________________.-'
        ASCII art from: {1}
        {2} {3} is proudly served by Python {4}.{5}.{6}.'''.
        format(__version__, url, program_name, __version__, *python_version)
    )

    formatter_class = argparse.RawTextHelpFormatter
    description = "A delicious AUR helper. Made from cower."
    parser = argparse.ArgumentParser(description=description,
                                     formatter_class=formatter_class)
    parser.add_argument("--cower-raw-options", nargs=argparse.REMAINDER,
                        default=[], help="pass arguments directly to cower"
                        "\nWARNING: no sanity check, may break things")
    parser.add_argument("--non-interactive", action="store_true",
                        help="skip interactive prompts during install process"
                        "\nWARNING: possibly unsafe")
    parser.add_argument("--version", action="version", version=version_info)
    update = parser.add_argument_group("update")
    update.add_argument("-fu", "--force-update", metavar="TARGET",
                        nargs="+", default=[],
                        help="force update of installed AUR packages with"
                        "\ntarget name, useful for updating VCS packages"
                        "\ni.e. '-fi=-git' should update all Git packages")
    update.add_argument("-su", "--system-update", action="store_true",
                        help="update all AUR packages")
    install = parser.add_argument_group("install")
    install.add_argument("-mi", "--make-install", metavar="PACKAGE",
                         nargs="+", default=[],
                         help="make and install package from AUR including"
                         "\ndependencies")
    install.add_argument("-si", "--search-install", metavar="TARGET",
                         help="list all packages with target name and let"
                         "\nuser choose which ones to install")
    return parser


def main():
    """Main program function"""
    parser = _argparser()
    if len(sys.argv) == 1:
        parser.print_usage()
        sys.exit(1)
    args = parser.parse_args()

    # Check dependencies
    if os.geteuid() == 0:
        sys.exit("You should run {} as a non-root user.".format(sys.argv[0]))
    if not PACMAN_PATH:
        sys.exit("Could not find pacman installed. Are you using Arch Linux?")
    if not MAKEPKG_PATH:
        sys.exit("Could not find makepkg installed. Are you using Arch Linux?")
    if not COWER_PATH:
        sys.exit("Could not find cower installed. Install it from {}"
                 .format(COWER_URL))
    if args.non_interactive and not MC_PATH:
        print("Midnight Commander is not installed. "
              "Ignoring --non-interactive.", file=sys.stderr)

    # Allow user to pass options directly to cower
    global COWER_CMD
    COWER_CMD += args.cower_raw_options

    try:
        for target in args.force_update:
            force_update(target, args.non_interactive)
        for package in args.make_install:
            make_install(package, True, args.non_interactive)
        if args.system_update:
            system_update(args.non_interactive)
        if args.search_install:
            search_install(args.search_install)
    except KeyboardInterrupt:
        sys.exit("\nUser cancelled operation.")
    except Exception as e:
        if __debug__:
            import traceback
            sys.exit(traceback.format_exc())
        else:
            sys.exit(str(e).capitalize())


if __name__ == "__main__":
    main()

# vim: ts=8 et sw=4 sts=4
