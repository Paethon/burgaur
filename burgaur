#!/usr/bin/python -O

"""burgaur - A delicious AUR helper. Made from cower.

Burgaur is an AUR helper based on and strictly a superset of cower. It
automates of boring tasks that in cower you need to do by hand, like
updating all your AUR system packages or installing a new package from
AUR including its dependencies.

It doesn't try to be everything (i.e. like yaourt). Instead, it simple
assume that there is already a better tool to do some job and only
tries to complement other tools.
"""

import argparse
import glob
import os
import re
import subprocess
import sys
import tempfile
from distutils.spawn import find_executable
from shutil import rmtree
from textwrap import dedent

from blessings import Terminal

__author__ = "Thiago Kenji Okada"
__license__ = "MIT"
__version__ = "1.1"
__maintainer__ = "Thiago Kenji Okada"
__email__ = "thiago DOT mast3r AT gmail DOT com"
__status__ = "Stable"


# Initialize blessings
t = Terminal()


# Class definitions
class BurgaurError(Exception):

    """Generic Burgaur exception, used by Burgaur class"""

    pass


class Burgaur(object):

    """Main burgaur class

    Keyword arguments:
    pacman_path -- path to pacman (default: pacman)
    makepkg_path -- path to makepkg (default: makepkg)
    cower_path -- path to cower (default: cower)
    mc_path -- path to pacman (default: mc)
    encoding -- system encoding from LANG environmental variable
    (default: utf8)
    tempdir -- location of temporary directory used to build packages.
    "None" means default Python location, see tempfile.tempdir for
    details (default: None)
    cower_raw_options -- extra arguments to use by default when
    running cower. WARNING: there is no sanity checking, this may
    break things (default: None)
    noinstall -- do not install packages after build. If True
    assume nodelete=True too (default: False)
    nodelete -- do not remove temporary directory after build
    (default: False)
    noconfirm -- skip interactive prompts during install process;
    WARNING: possibly unsafe (default: False)
    """

    def __init__(self, pacman_path="pacman", makepkg_path="makepkg",
                 cower_path="cower", mc_path="mc", encoding="utf8",
                 tempdir=None, cower_raw_options=None, noinstall=False,
                 nodelete=False, noconfirm=False):
        self.pacman_path = pacman_path
        self.makepkg_path = makepkg_path
        self.cower_path = cower_path
        self.mc_path = mc_path
        self.encoding = encoding
        self.tempdir = tempdir
        self.cower_cmd = [self.cower_path]
        if cower_raw_options:
            self.cower_cmd += cower_raw_options
        if noinstall:
            self.noinstall = True
            self.nodelete = True
        else:
            self.noinstall = False
            self.nodelete = nodelete
        self.noconfirm = noconfirm

    def check_updates(self):
        """Check available updates for AUR packages.

        In case of sucess it returns a list of strings with each
        package that can be updated or None if there is no update
        available. In case of error it force exit with return code 1,
        including a user friendly message.

        Raises a BurgaurError in case of error.
        """
        cmd = self.cower_cmd + ["--color=never", "--update", "--quiet"]
        process = subprocess.Popen(cmd, stdout=subprocess.PIPE)
        out, err = process.communicate()

        # According to issue https://github.com/falconindy/cower/issues/32,
        # cower returns 1 if there is packages to update, 0 if there is
        # nothing, and anything else if there is a error.
        if process.returncode == 1:
            packages = out.decode(encoding=self.encoding).split("\n")[:-1]
            return packages
        elif process.returncode == 0:
            return None
        else:
            raise BurgaurError("cower could not get packages to update")

    def force_update(self, target):
        """Force update of packages from AUR with target name.

        The user case of this function is to update VCS packages. For
        example, you could pass target="-git", and since the majority
        of Git packages on AUR finishes with "-git" prefix it would
        try to update all of them.

        Since it's difficult to know if VCS packages are up-to-date
        or not unless we build it and try to install, please doesn't
        expect any intelligence from using this function.

        target -- a package name, may be partial match
        """
        cmd = [self.pacman_path, "--query",
               "--foreign", "--quiet",
               "--color", "never"]
        installed_packages = subprocess.check_output(cmd)
        installed_packages = installed_packages.decode(encoding=self.encoding)
        installed_packages = installed_packages.split("\n")[:-1]
        filtered_packages = [x for x in installed_packages
                             if x.find(target) >= 0]

        if filtered_packages:
            print("Packages to update:", end=" " + t.bold)
            print(*filtered_packages, sep=", ", end=t.normal + "\n")

            for package in filtered_packages:
                try:
                    self.make_install(package)
                except BurgaurError as e:
                    # Ignore make_install errors in this case
                    print_format_or_exc(e)
        else:
            print(t.bold_yellow("No packages with target {} found"
                                .format(target)))

    def make_install(self, package, install_deps=False):
        """Download, make and install package.

        This function creates a temporary directory, downloads the
        PKGBUILD using 'cower -d' and make/install the package using
        'makepkg -si' command.

        Raises a BurgaurError in case of error.

        Keyword arguments:
        package -- desired package to be installed (must match a
        package name on AUR)
        install_deps -- use cower '-dd' instead of only '-d' to
        download AUR dependencies and install them before the main
        package (default: False)
        """
        if not self.noconfirm:
            query = query_yes_no(t.bold("Do you want to install package {}")
                                 .format(package), default="yes")
            if not query:
                return

        target_dir = tempfile.mkdtemp(prefix="burgaur-", dir=self.tempdir)
        # makepkg_base_cmd may be used in case the package is splitted.
        # In this case, even if the user wants to install we don't pass
        # --install to makepkg, instead we install manually using pacman.
        makepkg_base_cmd = [self.makepkg_path, "--syncdeps"]
        makepkg_cmd = list(makepkg_base_cmd)
        pacman_cmd = ["sudo", self.pacman_path, "--upgrade"]
        cower_cmd = self.cower_cmd + ["--download", package,
                                      "--target", target_dir]
        if not self.noinstall:
            makepkg_cmd += ["--install"]
        if self.noconfirm:
            makepkg_cmd += ["--noconfirm"]
            pacman_cmd += ["--noconfirm"]
        if install_deps:
            cower_cmd += ["--download"]

        try:
            subprocess.check_call(cower_cmd)
        except subprocess.CalledProcessError:
            raise BurgaurError("cower failed to download {} or its "
                               "depedencies".format(package))
        os.chdir(target_dir)
        package_base = None
        try:
            packages_dir = os.listdir()
            # We remove and append the package in packages list to ensure
            # that the dependencies are installed before the main package.
            try:
                packages_dir.remove(package)
                packages_dir.append(package)
            except ValueError:
                # We could remove this try by deciding from _get_package_base
                # output if there is or not a PackageBase, but
                # _get_package_base is slow since it uses another subprocess.
                print(t.bold_yellow("Directory {} not found, trying to find "
                                    "PackageBase."
                                    .format(package)), file=sys.stderr)
                package_base = self._get_package_base(package)
                if package_base:
                    print(t.green_bold("PackageBase {} found. Trying to "
                                       "build from it.".format(package_base)))
                    packages_dir.remove(package_base)
                    packages_dir.append(package_base)
                else:
                    raise BurgaurError("directory from package {} not found, "
                                       "and not a splitted package"
                                       .format(package))
            for package_dir in packages_dir:
                os.chdir(package_dir)
                if not self.noconfirm:
                    self.view_in_mc(package)
                if package_dir == package_base:
                    subprocess.check_call(makepkg_base_cmd)
                    if not self.noinstall:
                        pkg = glob.glob(package + "-*.pkg.tar*")[0]
                        subprocess.check_call(pacman_cmd + [pkg])
                else:
                    subprocess.check_call(makepkg_cmd)
        except subprocess.CalledProcessError:
            raise BurgaurError("error while installing package {}"
                               .format(package))
        finally:
            if not self.nodelete:
                print(t.bold("Cleaning up directory {}.".format(target_dir)))
                rmtree(target_dir)

    def system_update(self):
        """Updates all AUR packages that have updates."""
        packages = self.check_updates()
        if packages:
            print("Packages to update:", end=" " + t.bold)
            print(*packages, sep=", ", end=t.normal + "\n")

            for package in packages:
                try:
                    self.make_install(package)
                except BurgaurError as e:
                    # Ignore make_install errors in this case
                    print_format_or_exc(e)
        else:
            print(t.bold("All packages are up-to-date."))

    def search_package(self, target):
        """Search and returns packages that matches target.

        This function uses 'cower -s target' to search packages that
        matches a certain target, parse cower output and returns a
        list of dictionaries containing info about all found packages.

        Each dictionary contains the following keys: category, name,
        version, description, maintainer and votes. For now this info
        is hard-coded but it may be dynamically generated in the
        future.

        Keyword arguments:
        target -- target for 'cower -s target'
        """
        package_info = ["category", "name", "version", "description",
                        "maintainer", "votes", "out_of_date"]
        # output: package++1.0.0++package description++maintainer++123\n
        cmd = self.cower_cmd + ["--format=%c;;%n;;%v;;%d;;%m;;%o;;%t\n",
                                "--color=never",
                                "--search", target]
        process = subprocess.Popen(cmd,
                                   stdout=subprocess.PIPE,
                                   stderr=subprocess.PIPE)
        out, err = process.communicate()
        if err:
            raise BurgaurError("error while searching for target {}"
                               .format(target))

        result = []
        packages = out.decode(self.encoding).split("\n")[:-1]
        for package in packages:
            entry = zip(package_info, package.split(";;"))
            result.append(dict(entry))
        return result

    def search_install(self, target):
        """Search target, display packages that match it and install
        them.

        This function searches the target on AUR, display all results
        to the user in a enumerated way and ask user which ones it
        should install.

        There isn't many sanity checks of the user input. The user may
        install the same package twice, for example.

        Keyword arguments:
        target -- target to search on AUR
        """
        packages = self.search_package(target)
        if not packages:
            print(t.bold_yellow("No packages with target {} found."
                                .format(target)))

        for i, package in enumerate(packages, start=1):
            position = t.bold(str(i) + ")")
            category = t.bold_magenta(package["category"] + "/")
            name = t.bold(package["name"])
            maintainer = "by " + t.bold_yellow(package["maintainer"])
            if package["out_of_date"] == "no":
                version = t.bold_green(package["version"])
            else:
                version = t.bold_red(package["version"])
            votes = "(" + package["votes"] + ")"
            description = "\n    " + package["description"]
            # I know this seems to be a pretty bad way to format a string,
            # but there are too many different colors here so we need to
            # improvise.
            print(position, category + name, maintainer, version, votes,
                  description)

        prompt = t.bold("Select packages (use comma to select multiple "
                        "packages, dash for ranges): ")
        selected_packages = parse_int_from_input(prompt)

        if selected_packages:
            for i in selected_packages:
                if i < 1:
                    raise ValueError("invalid zero/negative value")
                self.make_install(packages[i - 1]["name"], True)
        else:
            print(t.bold_yellow("No package selected"), file=sys.stderr)

    def view_in_mc(self, package, directory="."):
        """"View package contents with Midnight Commander.

        Keyword arguments:
        package -- package name
        directory -- directory to open in mc (default: ".")
        """
        if self.mc_path:  # only runs if mc is installed, otherwise ignore it
            query = query_yes_no(t.bold("Do you want to view package {} "
                                        "contents in mc?"
                                        .format(package)), default="yes")
            if query:
                subprocess.call([self.mc_path, directory])

    def _get_package_base(self, package):
        """Get package base name.

        This is an ugly hack until this issue is solved:
        https://github.com/falconindy/cower/issues/105

        Keyword arguments:
        package -- package to get PackageBase information
        """
        cower_cmd = self.cower_cmd + ["--color=never", "--info", package]
        try:
            out = subprocess.check_output(cower_cmd).decode(self.encoding)
        except subprocess.CalledProcessError:
            raise BurgaurError("error while getting package {} info"
                               .format(package))
        result = re.findall(r"PackageBase\s+: (.+)", out)
        if result:
            return result[0]
        else:
            return None


# Auxiliary functions
def query_yes_no(question, default=None):
    """Ask a yes/no question via input() and return their answer.

    Return True in case of "yes" and False in case of "no".

    Modified version from http://stackoverflow.com/a/3041990, rewrite
    some parts to be more Pythonic.

    Keyword arguments:
    question -- string present to the user
    default -- default answer if the user just hits enter; None doesn't
    assume anything (default: None).
    """
    valid = {"yes": True, "y": True,
             "no": False, "n": False}
    if default is None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("invalid default answer: {}".format(default))

    while True:
        print("{}{}".format(question, prompt), end="")
        choice = input().lower()
        try:
            if choice:
                return valid[choice]
            else:
                return valid[default]
        except KeyError:
            print(t.bold_yellow("Please respond with (y)es or (n)o."))


def parse_int_from_input(prompt=None):
    """Ask input from user, tries to parse input for integers.

    User may pass only one value ("1"), multiple values separated by
    comma ("1,2,5") or a range of values separated by dash ("2-8") or
    any combination of above ("1-2,3").

    Keyword arguments:
    prompt -- prompt from input() function (default: None)
    """
    exclude_regex = re.compile(r"[^0-9,-]")
    find_regex = re.compile(r"([0-9]+-[0-9]+)|(-?[0-9]+)")
    while True:
        result = []
        user_input = input(prompt)
        # If user entered any invalid character, the exclude_regex will
        # match something
        if not exclude_regex.search(user_input):
            found_items = find_regex.findall(user_input)
            for item in found_items:
                if item[0]:
                    i, j = item[0].split("-")
                    result += list(range(int(i), int(j) + 1))
                if item[1]:
                    result.append(int(item[1]))
            break
        else:
            print(t.bold_yellow("Invalid value. Please enter a number. "
                                "You may enter multiple values using comma "
                                "(i.e.: 1,2,3) or a range of values using "
                                "dash (i.e.: 1-3)."), file=sys.stderr)
    return result


def print_format_or_exc(e):
    """Print error in user friendly way or stack trace if in debug mode

    Keyword arguments:
    e -- error message from exception
    """
    if __debug__:
        import traceback
        traceback.print_exc()
    else:
        print(t.bold_red("Error:"), t.bold(str(e)), file=sys.stderr)


# main() and auxiliary functions
def _argparser():
    """Print and parse arguments"""
    program_name = os.path.basename(sys.argv[0]).title()
    url = "http://www.retrojunkie.com/asciiart/food/burgers.htm"
    python_version = sys.version_info[:3]
    version_info = dedent(
        r'''
                          {0}
                 _....----"""----...._
              .-'  o    o    o    o   '-.
             /  o    o    o         o    \
            /     o      o   o     o    o \
          _|   o   o    o      o  o     o  |_
         / `''-----.................-----''` \
         \___________________________________/
           \~`-`.__.`-~`._.~`-`~.-~.__.~`-`/
            \                             /
             `-._______________________.-'
        ASCII art from: {1}
        {2} {3} is proudly served by Python {4}.{5}.{6}.'''.
        format(__version__, url, program_name, __version__, *python_version)
    )

    formatter_class = argparse.RawTextHelpFormatter
    description = "A delicious AUR helper. Made from cower."
    parser = argparse.ArgumentParser(description=description,
                                     formatter_class=formatter_class)
    parser.add_argument("--cower-raw-options", nargs=argparse.REMAINDER,
                        default=[], help="pass arguments directly to cower"
                        "\nWARNING: no sanity check, may break things")
    parser.add_argument("--noconfirm", action="store_true",
                        help="skip confirmation prompts during install process"
                        "\nWARNING: may be unsafe")
    parser.add_argument("--nodelete", action="store_true",
                        help="do not remove temporary build directory after"
                        "\ninstall")
    parser.add_argument("--noinstall", action="store_true",
                        help="do not install packages after build"
                        "\nassume '--nodelete'")
    parser.add_argument("-c", "--color", metavar="WHEN", action="store",
                        default="auto",
                        help="use colored output. WHEN is 'never', 'always'"
                        "\nor 'auto' (default)")
    parser.add_argument("--version", action="version", version=version_info)
    update = parser.add_argument_group("update")
    update.add_argument("-fu", "--force-update", metavar="TARGET",
                        nargs="+", default=[],
                        help="force update of installed AUR packages with"
                        "\ntarget name, useful for updating VCS packages"
                        "\ni.e. '-fi=-git' should update all Git packages")
    update.add_argument("-su", "--system-update", action="store_true",
                        help="update all AUR packages")
    install = parser.add_argument_group("install")
    install.add_argument("-mi", "--make-install", metavar="PACKAGE",
                         nargs="+", default=[],
                         help="make and install package from AUR including"
                         "\ndependencies")
    install.add_argument("-si", "--search-install", metavar="TARGET",
                         help="list all packages with target name and let"
                         "\nuser choose which ones to install")
    return parser


def main():
    """Main program function"""
    parser = _argparser()
    if len(sys.argv) == 1:
        parser.print_usage()
        sys.exit(1)
    args = parser.parse_args()

    # Yeah, I know, ugly global variable. But I don't know a better way to
    # handle blessings without passing even uglier instancies to every
    # class/function.
    global t
    if args.color.lower() == "never":
        t = Terminal(force_styling=None)
    elif args.color.lower() == "always":
        t = Terminal(force_styling=True)
    elif args.color.lower() == "auto":
        # This is the default, btw
        t = Terminal(force_styling=False)

    # Get executable paths and some important environmental vars
    pacman_path = find_executable("pacman")
    makepkg_path = find_executable("makepkg")
    cower_path = find_executable("cower")
    mc_path = find_executable("mc")  # mc is an optional dependency
    encoding = os.getenv("LANG", ".utf8").split(".")[1]
    # In Arch Linux, /tmp is mounted as tmpfs. It would be a bad idea to
    # compile big packages completely on RAM, so by default we use /var/tmp.
    # The user may overrides this setting by setting BURGAUR_TARGET_DIR.
    tempdir = os.getenv("BURGAUR_TARGET_DIR", "/var/tmp")

    # Sanity checks
    if os.geteuid() == 0:
        sys.exit(t.bold_red("You should run {} as a non-root user."
                            .format(sys.argv[0])))
    if not pacman_path:
        sys.exit(t.bold_red("Could not find pacman installed. Are you using "
                            "Arch Linux?"))
    if not makepkg_path:
        sys.exit(t.bold_red("Could not find makepkg installed. Are you using "
                            "Arch Linux?"))
    if not cower_path:
        cower_url = "https://aur.archlinux.org/packages/cower/"
        sys.exit(t.bold_red("Could not find cower installed. Install it "
                            "from {}.".format(cower_url)))

    # Initialize main class
    burgaur = Burgaur(pacman_path, makepkg_path, cower_path, mc_path,
                      encoding, tempdir, args.cower_raw_options,
                      args.noinstall, args.nodelete, args.noconfirm)

    try:
        for target in args.force_update:
            burgaur.force_update(target)
        for package in args.make_install:
            burgaur.make_install(package, True)
        if args.system_update:
            burgaur.system_update()
        if args.search_install:
            burgaur.search_install(args.search_install)
    except KeyboardInterrupt:
        sys.exit(t.bold_yellow("\nUser cancelled operation."))
    except Exception as e:
        print_format_or_exc(e)
        sys.exit(1)


if __name__ == "__main__":
    main()

# vim: ts=8 et sw=4 sts=4
