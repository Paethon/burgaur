#!/usr/bin/python -O

"""burgaur - A delicious AUR helper. Made from cower.

Burgaur is strictly a superset of cower. It automates of boring tasks
that in cower you need to do by hand, like updating all your AUR system
packages or installing a new package from AUR including its
dependencies.

It doesn't try to be everything (i.e. like yaourt). Instead, it simple
assume that there is already a better tool to do some job and only
tries to complement other tools.

"""

import argparse
import os
import re
import subprocess
import sys
import tempfile
from distutils.spawn import find_executable
from shutil import rmtree
from textwrap import dedent

__author__ = "Thiago Kenji Okada"
__license__ = "MIT"
__version__ = "0.5"
__maintainer__ = "Thiago Kenji Okada"
__email__ = "thiago DOT mast3r AT gmail DOT com"
__status__ = "Development"

COWER_URL = "https://aur.archlinux.org/packages/cower/"
PACMAN_PATH = find_executable("pacman")
MAKEPKG_PATH = find_executable("makepkg")
COWER_PATH = find_executable("cower")
COWER_CMD = [COWER_PATH]
MC_PATH = find_executable("mc")  # mc is an optional dependency
ENCODING = os.getenv("LANG", ".utf8").split(".")[1]
# In Arch Linux, /tmp is mounted as tmpfs. It would be a bad idea to compile
# big packages completely on RAM, so by default we use /var/tmp. Anyway, the
# user can overrides this setting by setting env variable BURGAUR_TARGET_DIR.
tempfile.tempdir = os.getenv("BURGAUR_TARGET_DIR", "/var/tmp")


# Internal error class
class BurgaurError(Exception):
    pass


# Auxiliary functions
def query_yes_no(question, default=None):
    """Ask a yes/no question via input() and return their answer.

    Return True in case of "yes" and False in case of "no".

    Modified version from http://stackoverflow.com/a/3041990, rewrite
    some parts to be more Pythonic.

    Keyword arguments:
    question -- string present to the user
    default -- default answer if the user just hits enter; None doesn't
    assume anything (default: None).
    """
    valid = {"yes": True, "y": True,
             "no": False, "n": False}
    if default is None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("Invalid default answer: {}".format(default))

    while True:
        print("{}{}".format(question, prompt), end="")
        choice = input().lower()
        try:
            if choice:
                return valid[choice]
            else:
                return valid[default]
        except KeyError:
            print("Please respond with (y)es or (n)o.")


def view_in_mc(package, directory="."):
    """"View package contents with Midnight Commander.

    Keyword arguments:
    package -- package name
    directory -- directory to open in mc (default: ".")
    """
    if MC_PATH:  # only runs if mc is installed, otherwise ignore it
        query = query_yes_no("Do you want to view package {} contents in mc?"
                             .format(package), default="yes")
        if query:
            subprocess.call([MC_PATH, directory])


# AUR related functions
def check_updates():
    """Check available updates for AUR packages.

    In case of sucess it returns a list of strings with each package
    that can be updated or None if there is no update available.
    In case of error it force exit with return code 1, including a user
    friendly message.

    Raises a BurgaurError in case of error.
    """
    cmd = COWER_CMD + ["--color=never", "--update", "--quiet"]
    process = subprocess.Popen(cmd, stdout=subprocess.PIPE)
    out, err = process.communicate()

    # According to this issue https://github.com/falconindy/cower/issues/32,
    # cower returns 1 if there is packages to update, 0 if there is nothing,
    # and anything else if there is a error.
    if process.returncode == 1:
        packages = out.decode(encoding=ENCODING).split("\n")[:-1]
        return packages
    elif process.returncode == 0:
        return None
    else:
        raise BurgaurError("Error while checking for updates.")


def force_update(target, non_interactive=False):
    """Force update of packages from AUR with target name.

    The user case of this function is to update VCS packages. For
    example, you could pass target="-git", and since the majority of
    Git packages on AUR finishes with "-git" prefix it would try to
    update all of them.

    Since it's impossible to know if VCS packages are up-to-date or not
    unless we build it and try to install, please doesn't expect any
    intelligence from using this function.

    target -- a package name or a generic target; support glob
    expansion
    non_interactive -- update all packages without asking for user
    input; affect make_install function too (default: False)
    """
    cmd = [PACMAN_PATH, "-Q", "--foreign", "--quiet", "--color", "never"]
    installed_packages = subprocess.check_output(cmd)
    installed_packages = installed_packages.decode(encoding=ENCODING)
    installed_packages = installed_packages.split("\n")[:-1]
    filtered_packages = filter(lambda x: re.search(target, x),
                               installed_packages)
    for package in filtered_packages:
        if non_interactive:
            query = True
        else:
            query = query_yes_no("Do you want to update {}?".format(package),
                                 default="yes")
        if query:
            try:
                make_install(package, non_interactive=non_interactive)
            except BurgaurError as e:
                # Ignore make_install errors in this case
                print(e, file=sys.stderr)


def make_install(package, install_deps=False, non_interactive=False):
    """Download, make and install package.

    This function creates a temporary directory, downloads the PKGBUILD
    using 'cower -d' and make/install the package using 'makepkg -si'
    command.

    Raises a BurgaurError in case of error.

    Keyword arguments:
    package -- desired package to be installed (must match a package
    name on AUR)
    install_deps -- use cower '-dd' instead of only '-d' to download
    AUR dependencies and install them before the main package (default:
    False)
    non_interactive -- skip interactive prompts during install process;
    WARNING: possibly unsafe (default: False)
    """
    target_dir = tempfile.mkdtemp(prefix="burgaur-")
    makepkg_cmd = [MAKEPKG_PATH, "--syncdeps", "--install"]
    cower_cmd = COWER_CMD + ["--color=never", "--quiet",
                             "--download", package,
                             "--target", target_dir]
    if install_deps:
        cower_cmd += ["--download"]

    os.chdir(target_dir)
    try:
        subprocess.check_call(cower_cmd)
    except subprocess.CalledProcessError:
        raise BurgaurError("Error while downloading package {} or its "
                           "depedencies.".format(package))
    try:
        packages = os.listdir()
        # We remove and append the package in packages list to ensure
        # that the dependencies are installed before the main package.
        packages.remove(package)
        packages.append(package)
        for package in packages:
            os.chdir(package)
            if not non_interactive:
                view_in_mc(package)
            subprocess.check_call(makepkg_cmd)
            os.chdir(target_dir)
    except subprocess.CalledProcessError:
        raise BurgaurError("Error while installing package {}."
                           .format(package))
    finally:
        rmtree(target_dir)


def system_update(non_interactive=False):
    """Updates all AUR packages that have updates

    Keyword arguments:
    non_interactive -- see make_install function (default: False)
    """
    packages = check_updates()
    if packages:
        for package in packages:
            if non_interactive:
                query = True
            else:
                query = query_yes_no("Do you want to update {}?"
                                     .format(package), default="yes")
            if query:
                try:
                    make_install(package, non_interactive=non_interactive)
                except BurgaurError as e:
                    # Ignore make_install errors in this case
                    print(e, file=sys.stderr)
    else:
        print("All packages are up-to-date.")


def super_search(target):
    """Search a package based on passed target.

    For now, this is basically a wrapper around 'cower --search' AND
    'cower --msearch' at the same time, running two subprocess in
    parallel. This may be completely overkill, but it works.

    Keyword arguments:
    target -- desired target (maybe a package name, its description,
    current maintainer, etc.)
    """
    cmd_search = COWER_CMD + ["--search", target]
    p_search = subprocess.Popen(cmd_search)

    cmd_msearch = COWER_CMD + ["--msearch", target]
    p_msearch = subprocess.Popen(cmd_msearch)

    p_search.communicate()
    p_msearch.communicate()


# main() and auxiliary functions
def _argparser():
    """Print and parse arguments"""
    program_name = os.path.basename(sys.argv[0]).title()
    url = "http://www.retrojunkie.com/asciiart/food/burgers.htm"
    python_version = sys.version_info[:3]
    version_info = dedent(
        r'''
                          {0}
                 _....----"""----...._
              .-'  o    o    o    o   '-.
             /  o    o    o         o    \
            /     o      o   o     o    o \
          _|   o   o    o      o  o     o  |_
         / `''-----.................-----''` \
         \___________________________________/
           \~`-`.__.`-~`._.~`-`~.-~.__.~`-`/
            \                             /
             `-._______________________.-'
        ASCII art from: {1}
        {2} {3} is proudly served by Python {4}.{5}.{6}.'''.
        format(__version__, url, program_name, __version__, *python_version)
    )

    formatter_class = argparse.RawTextHelpFormatter
    description = "A delicious AUR helper. Made from cower."
    parser = argparse.ArgumentParser(description=description,
                                     formatter_class=formatter_class)
    parser.add_argument("--non-interactive", action="store_true",
                        help="skip interactive prompts during install process"
                        "\nWARNING: possibly unsafe")
    parser.add_argument("--version", action="version", version=version_info)
    parser.add_argument("--cower-raw-options", nargs=argparse.REMAINDER,
                        default=[], help="pass arguments directly to cower"
                        "\nWARNING: no sanity check, may break thigs")
    search = parser.add_argument_group("search")
    search.add_argument("-ss", "--super-search", metavar="TARGET",
                        help="search packages by description, name and/or"
                        "\nmaintainer")
    update = parser.add_argument_group("update")
    update.add_argument("-fu", "--force-update", metavar="TARGET",
                        help="force update of installed AUR packages with"
                        "\ntarget name, useful for updating VCS packages"
                        "\ni.e. '-fi=-git' should update all Git packages")
    update.add_argument("-su", "--system-update", action="store_true",
                        help="update all AUR packages")
    install = parser.add_argument_group("install")
    install.add_argument("-mi", "--make-install", metavar="PACKAGE",
                         nargs="+", default=[],
                         help="make and install package from AUR including"
                         "\ndependencies")
    return parser


def main():
    """Main program function"""
    parser = _argparser()
    if len(sys.argv) == 1:
        parser.print_usage()
        sys.exit(1)
    args = parser.parse_args()

    # Check dependencies
    if os.geteuid() == 0:
        sys.exit("You should run {} as a non-root user.".format(sys.argv[0]))
    if not PACMAN_PATH:
        sys.exit("Could not find pacman installed. Are you using Arch Linux?")
    if not MAKEPKG_PATH:
        sys.exit("Could not find makepkg installed. Are you using Arch Linux?")
    if not COWER_PATH:
        sys.exit("Could not find cower installed. Install it from {}"
                 .format(COWER_URL))
    if args.non_interactive and not MC_PATH:
        print("Midnight Commander is not installed. "
              "Ignoring --non-interactive.", file=sys.stderr)

    # Allow user to pass options directly to cower
    global COWER_CMD
    COWER_CMD += args.cower_raw_options

    try:
        if args.force_update:
            force_update(args.force_update, args.non_interactive)
        if args.super_search:
            super_search(args.super_search)
        if args.system_update:
            system_update(args.non_interactive)
        for package in args.make_install:
            make_install(package, True, args.non_interactive)
    except BurgaurError as e:
        if __debug__:
            import traceback
            sys.exit(traceback.format_exc())
        else:
            sys.exit(e)
    except KeyboardInterrupt:
        sys.exit("\nUser cancelled operation.")


if __name__ == "__main__":
    main()

# vim: ts=8 et sw=4 sts=4
